-- ЧАСТЬ 1

--Задание 1: 
--Для каждого города выведите число покупателей из соответствующей таблицы, сгруппированных по возрастным категориям и отсортированных по убыванию количества покупателей в каждой категории.

--Примечание: под возрастной категорией подразумевается возраст человека в полных годах (например, 21, 35, 65 и т.д.). Можете дополнительно написать запрос именно для “категорий”: от 0 до 20 (категория young), от 21 до 49 (категория adult), от 50 и выше (категория old)

SELECT 
    city, -- Я выбираю колонку "город".
    CASE 
        WHEN age < 20 THEN '0-19' -- Здесь я разбиваю пользователей на категории: от 0 до 19 лет.
        WHEN age BETWEEN 20 AND 29 THEN '20-29' -- От 20 до 29 лет.
        WHEN age BETWEEN 30 AND 39 THEN '30-39' -- От 30 до 39 лет.
        WHEN age BETWEEN 40 AND 49 THEN '40-49' -- От 40 до 49 лет.
        WHEN age BETWEEN 50 AND 59 THEN '50-59' -- От 50 до 59 лет.
        WHEN age BETWEEN 60 AND 69 THEN '60-69' -- От 60 до 69 лет.
        ELSE '70+' -- Все остальные попадают в категорию "70+".
    END AS age_category, -- Я создаю новую колонку "возрастная категория".
    COUNT(*) AS customer_count -- Считаю, сколько пользователей в каждой категории.
FROM users_wb uw -- Я беру данные из таблицы "users_wb".
GROUP BY city, age_category -- Группирую данные по городам и возрастным категориям.
ORDER BY customer_count DESC; -- Сортирую так, чтобы самые большие группы были первыми.

SELECT 
    city, -- Я выбираю колонку "город".
    CASE
        WHEN age <= 20 THEN 'young' -- Возраст до 20 лет я отношу к категории "молодые".
        WHEN age BETWEEN 21 AND 49 THEN 'adult' -- Возраст от 21 до 49 лет попадает в категорию "взрослые".
        ELSE 'old' -- Возраст от 50 лет и старше я считаю "старшими".
    END AS age_group, -- Я создаю новую колонку "возрастная группа".
    COUNT(*) AS customer_count -- Подсчитываю, сколько пользователей в каждой группе.
FROM users_wb -- Беру данные из таблицы "users_wb".
GROUP BY city, age_group -- Группирую по городам и возрастным группам.
ORDER BY city, customer_count DESC; -- Сортирую по городу, а внутри — по количеству пользователей (по убыванию).


--Задание 2:
--Рассчитайте среднюю цену категорий товаров в таблице products, в названиях товаров которых присутствуют слова «hair» или «home». Среднюю цену округлите до двух знаков после запятой. Столбец с полученным значением назовите avg_price. 
--Поля в результирующей таблице: avg_price, category.

--Пояснение: Для решения этой задачи подойдёт конструкция CASE. В качестве возраста учитывайте число полных лет.

SELECT 
    round(avg(price), 2) as avg_price, -- Я рассчитываю среднюю цену для каждой категории и округляю её до двух знаков после запятой.
    category -- Я выбираю колонку "категория".
FROM products_wb -- Я беру данные из таблицы "products_wb".
WHERE lower(name) LIKE '%home%' OR lower(name) LIKE '%hair%' -- Я фильтрую продукты, чтобы выбрать только те, в названии которых есть слова "home" или "hair" 
GROUP BY category -- Я группирую данные по категориям продуктов.
ORDER BY avg_price DESC; -- Я сортирую категории по средней цене в порядке убывания, начиная с самых дорогих.


--ЧАСТЬ 2

--Задание 1: 
--Назовем “успешными” (’rich’) селлерами тех:
--кто продает более одной категории товаров
--кто продает более одной категории товаров
--Остальные селлеры (продают более одной категории, но чья суммарная выручка менее 50 000) будут обозначаться как ‘poor’. Выведите для каждого продавца количество категорий, средний рейтинг его категорий, суммарную выручку, а также метку ‘poor’ или ‘rich’.

--Назовите поля: seller_id, total_categ, avg_rating, total_revenue, seller_type.Выведите ответ по возрастанию id селлера.
--Примечание: Категория “Bedding” не должна учитываться в расчетах.

WITH filtered_data AS ( -- Я начинаю с подзапроса "filtered_data", чтобы отфильтровать продавцов, исключив категорию 'Bedding'.
    SELECT 
        seller_id, -- Я выбираю идентификатор продавца.
        category, -- Я выбираю категорию товара.
        revenue, -- Я выбираю доход продавца.
        rating -- Я выбираю рейтинг продавца.
    FROM sellers -- Я беру данные из таблицы "sellers".
    WHERE category != 'Bedding' -- Я исключаю продавцов из категории "Bedding".
),

seller_statistic AS ( -- Я создаю второй подзапрос "seller_statistic", чтобы подсчитать статистику для каждого продавца.
    SELECT 
        seller_id, -- Я выбираю идентификатор продавца.
        COUNT(DISTINCT category) AS total_categ, -- Я считаю количество уникальных категорий, в которых работает продавец.
        ROUND(AVG(rating), 2) AS avg_rating, -- Я вычисляю средний рейтинг продавца, округляя его до двух знаков.
        SUM(revenue) AS total_revenue -- Я суммирую общий доход продавца.
    FROM filtered_data -- Я использую данные, отфильтрованные в предыдущем подзапросе.
    GROUP BY seller_id -- Я группирую результаты по продавцам.
),

classified_sellers AS ( -- Я создаю третий подзапрос "classified_sellers", чтобы классифицировать продавцов по типу.
    SELECT 
        seller_id, -- Я выбираю идентификатор продавца.
        total_categ, -- Я беру количество категорий для продавца.
        avg_rating, -- Я беру средний рейтинг продавца.
        total_revenue, -- Я беру общий доход продавца.
        CASE 
            WHEN total_categ > 1 AND total_revenue > 50000 THEN 'rich' -- Если продавец работает в нескольких категориях и имеет доход больше 50000, я классифицирую его как 'rich'.
            ELSE 'poor' -- В противном случае, я классифицирую его как 'poor'.
        END AS seller_type -- Я создаю колонку "seller_type" с типом продавца ('rich' или 'poor').
    FROM seller_statistic -- Я использую данные, подсчитанные на предыдущем шаге.
)

SELECT 
    seller_id, -- Я выбираю идентификатор продавца.
    total_categ, -- Я выбираю количество категорий для продавца.
    avg_rating, -- Я выбираю средний рейтинг продавца.
    total_revenue, -- Я выбираю общий доход продавца.
    seller_type -- Я выбираю тип продавца (rich/poor).
FROM classified_sellers; -- Я получаю итоговый результат из классифицированных продавцов.


--Задание 2
--Для каждого из неуспешных продавцов (из предыдущего задания) посчитайте, сколько полных месяцев прошло с даты регистрации продавца.

--Отсчитывайте от того времени, когда вы выполняете задание. Считайте, что в месяце 30 дней. Например, для 61 дня полных месяцев будет 2.

--Также выведите разницу между максимальным и минимальным сроком доставки среди неуспешных продавцов. Это число должно быть одинаковым для всех неуспешных продавцов.

--Назовите поля: seller_id, month_from_registration ,max_delivery_difference.Выведите ответ по возрастанию id селлера.

--Примечание: Категория “Bedding” по-прежнему не должна учитываться в расчетах.



-- Удаляю временную таблицу "poor_sellers", если она уже существует.
DROP TABLE IF EXISTS poor_sellers;

-- Создаю временную таблицу "poor_sellers", чтобы сохранить данные о неуспешных продавцах.
CREATE TEMPORARY TABLE poor_sellers AS
WITH filtered_data AS ( -- Фильтрую данные, исключая категорию "Bedding".
    SELECT 
        seller_id, -- Идентификатор продавца.
        category, -- Категория продукта.
        revenue, -- Доход продавца.
        rating -- Рейтинг продавца.
    FROM sellers 
    WHERE category != 'Bedding' -- Исключаю товары категории "Bedding".
),

seller_statistic AS ( -- Рассчитываю статистику для каждого продавца.
    SELECT 
        seller_id, -- Идентификатор продавца.
        COUNT(DISTINCT category) AS total_categ, -- Количество уникальных категорий, в которых работает продавец.
        ROUND(AVG(rating), 2) AS avg_rating, -- Средний рейтинг продавца, округленный до двух знаков.
        SUM(revenue) AS total_revenue -- Общий доход продавца.
    FROM filtered_data 
    GROUP BY seller_id -- Группирую данные по продавцу.
),

classified_sellers AS ( -- Классифицирую продавцов по их успешности.
    SELECT 
        seller_id, -- Идентификатор продавца.
        total_categ, -- Количество категорий.
        avg_rating, -- Средний рейтинг.
        total_revenue, -- Общий доход.
        CASE 
            WHEN total_categ > 1 AND total_revenue > 50000 THEN 'rich' -- Если продавец успешен, классифицирую его как "rich".
            ELSE 'poor' -- Иначе — как "poor".
        END AS seller_type -- Тип продавца ("rich" или "poor").
    FROM seller_statistic
)

-- Выбираю только неуспешных ("poor") продавцов и добавляю их данные, включая дату регистрации и время доставки.
SELECT 
    cs.seller_id, -- Идентификатор продавца.
    cs.total_categ, -- Количество категорий.
    cs.avg_rating, -- Средний рейтинг.
    cs.total_revenue, -- Общий доход.
    cs.seller_type, -- Тип продавца (должен быть "poor").
    s.date_reg, -- Дата регистрации продавца.
    s.delivery_days -- Срок доставки.
FROM classified_sellers cs 
JOIN sellers s ON cs.seller_id = s.seller_id -- Присоединяю данные из таблицы "sellers".
WHERE seller_type = 'poor'; -- Учитываю только неуспешных продавцов.

-- Определяю дату первой регистрации каждого неуспешного продавца.
WITH first_reg_seller AS (
    SELECT 
        seller_id, -- Идентификатор продавца.
        MIN(date_reg) AS first_date_reg -- Первая дата регистрации продавца.
    FROM poor_sellers
    GROUP BY seller_id -- Группирую по продавцу.
),

-- Рассчитываю количество месяцев с даты первой регистрации и добавляю данные о сроках доставки.
seller_data AS (
    SELECT 
        ps.seller_id, -- Идентификатор продавца.
        ps.delivery_days, -- Срок доставки.
        FLOOR((CURRENT_DATE - TO_DATE(first_date_reg, 'DD/MM/YYYY')) / 30) AS month_from_registration -- Полные месяцы с даты регистрации, рассчитывая от текущей даты (беру 30 дней в месяце).
    FROM poor_sellers ps 
    JOIN first_reg_seller frs 
    ON ps.seller_id = frs.seller_id AND ps.date_reg = frs.first_date_reg -- Присоединяю продавцов с их первой датой регистрации.
),

-- Рассчитываю разницу между максимальным и минимальным сроком доставки среди всех неуспешных продавцов.
delivery_diff AS (
    SELECT 
        MAX(delivery_days) - MIN(delivery_days) AS max_delivery_difference -- Разница между максимальным и минимальным сроками доставки.
    FROM seller_data
)

-- Финальный запрос: вывожу данные о продавцах и разницу в сроках доставки.
SELECT 
    sd.seller_id, -- Идентификатор продавца.
    sd.month_from_registration, -- Полные месяцы с даты регистрации.
    dd.max_delivery_difference -- Разница между максимальным и минимальным сроками доставки (одинаковая для всех).
FROM seller_data sd
CROSS JOIN delivery_diff dd -- Использую CROSS JOIN, чтобы разница доставки была добавлена ко всем строкам.
ORDER BY sd.seller_id; -- Сортирую результат по идентификатору продавца в порядке возрастания.



--Задание 3:
--Отберите продавцов, зарегистрированных в 2022 году и продающих ровно 2 категории товаров с суммарной выручкой, превышающей 75 000.

--Выведите seller_id данных продавцов, а также столбец category_pair с наименованиями категорий, которые продают данные селлеры.

--Например, если селлер продает товары категорий “Game”, “Fitness”, то для него необходимо вывести пару категорий category_pair с разделителем “-” в алфавитном порядке (т.е. “Game - Fitness”).

--Поля в результирующей таблице: seller_id, category_pair

WITH seller_data AS ( -- Создаю подзапрос для обработки данных продавцов.
    SELECT 
        seller_id, -- Идентификатор продавца.
        category, -- Категория, в которой работает продавец.
        revenue, -- Доход продавца.
        date_part('year', TO_DATE(date_reg, 'DD/MM/YYYY')) AS reg_year -- Извлекаю год регистрации из даты.
    FROM sellers s -- Беру данные из таблицы "sellers".
),

filtered_sellers AS ( -- Фильтрую продавцов, зарегистрированных в 2022 году, и подсчитываю их показатели.
    SELECT 
        seller_id, -- Идентификатор продавца.
        STRING_AGG(category, ' - ' ORDER BY category) AS category_pair, -- Объединяю все категории продавца в строку, разделяя их через " - ", и сортирую по категориям.
        SUM(revenue) AS total_revenue, -- Суммирую общий доход продавца.
        COUNT(DISTINCT category) AS category_count -- Считаю количество уникальных категорий, в которых работает продавец.
    FROM seller_data
    WHERE reg_year = 2022 -- Учитываю только тех, кто зарегистрировался в 2022 году.
    GROUP BY seller_id -- Группирую данные по продавцу.
),

final_result AS ( -- Определяю продавцов, соответствующих критериям.
    SELECT 
        seller_id, -- Идентификатор продавца.
        category_pair -- Строка с категориями продавца.
    FROM filtered_sellers
    WHERE category_count = 2 -- Выбираю продавцов, которые работают ровно в двух категориях.
      AND total_revenue > 75000 -- И чей общий доход превышает 75000.
)

SELECT * FROM final_result; -- Вывожу результат с идентификаторами продавцов и их категориями.
